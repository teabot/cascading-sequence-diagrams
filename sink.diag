seqdiag {
  "<client>"; FlowConnector; Flow; "<task>"; Tap; Scheme; TupleEntryCollector;
  
  "<client>" -> FlowConnector [label="connect()"];
    FlowConnector --> Flow [label="<init>"];
      Flow -> Tap [label="flowConfInit()"];
      Flow <- Tap;
    FlowConnector <-- Flow;
    FlowConnector -> Tap [label="sinkConfInit()"];
      Tap -> Scheme [label="sinkConfInit()"];
      Tap <- Scheme;
    FlowConnector <- Tap;
  "<client>" <- FlowConnector [label="// returns Flow"];  

  "<client>" -> Flow [label="complete()"];

    Flow -> Tap [label="prepareResourceForWrite()", rightnote="new in 2.7,\nI think this\nruns here."];
    Flow <- Tap;
    
    === Begin cluster side processing ===
        
    Flow -> "<task>" [diagonal, label="<submit tasks>"];
    
      "<task>" -> Tap [label="openForWrite()"];
        Tap --> TupleEntryCollector [label="<init>"];
        Tap <-- TupleEntryCollector; 
      "<task>" <- Tap [label="// returns TupleEntryCollector"];
  
      "<task>" -> TupleEntryCollector [label="add()"];
        TupleEntryCollector -> Scheme [label="sinkPrepare()", rightnote="if !prepared"];
        TupleEntryCollector <- Scheme;
        TupleEntryCollector -> Scheme [label="sink()"];
        TupleEntryCollector <- Scheme;
      "<task>" <- TupleEntryCollector;
      
      "<task>" -> TupleEntryCollector [label="close()"];
        TupleEntryCollector -> Scheme [label="sinkCleanUp()"];
        TupleEntryCollector <- Scheme;  
      "<task>" <- TupleEntryCollector;
    
    Flow <- "<task>" [diagonal, label="<all tasks complete>"];
  
    === End cluster side processing ===
    
    Flow -> Tap [label="commitResource()", rightnote="on success"];
    Flow <- Tap;

    Flow -> Tap [label="rollbackResource()", rightnote="on failure"];
    Flow <- Tap;
    
  "<client>" <- Flow;
}